* 迷宫如数组所示：<br>
  ```
  int Maze[5][5]={
			0,1,0,0,0,
			0,1,0,1,0,
			0,0,0,0,0,
			0,1,1,1,0
			0,0,0,1,0,
	};
  ```
	  上数组表示一个迷宫，0：墙壁;1：路;要求只能横、竖走，不能斜着走。
	   找到从左上角到右下角所有的路线。
# 深度优先搜索
* 利用堆栈，把走过的路线记录并压栈。利用所走过路线的每个前趋点，保存
上一步走的位置，后继点表示下一步走的位置。<br>
例如：`pedecessor[4][4]`为（3，4）的坐标位置，表示从（3，4）->(4,4)<br>
* 其伪码如下：<br>
```
 将起点标记为已走过并`压栈`;
 while (栈非空) {
	 从栈顶弹出一个点p;
	 if (p这个点是终点)
		 break;
	 否则沿右、下、左、上四个方向探索相邻的点
	 if (和p相邻的点有路可走，并且还没走过)
		 将相邻的点标记为已走过并压栈，它的前趋就是p点;
 }
 if (p点是终点) {
	 打印p点的座标;
	 while (p点有前趋) {
		 p点 = p点的前趋;
		 打印p点的座标;
	 }
 } else
没有路线可以到达终点;
```
* 深度优先搜索图解
![](https://github.com/GXTAO/Algorithm/blob/master/Maze/Maze_stack/stackqueue.dfs.png)
# 广度优先搜索
* 利用队列
