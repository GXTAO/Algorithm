* 迷宫如数组所示：<br>
  ```
  int Maze[5][5]={
			0,1,0,0,0,
			0,1,0,1,0,
			0,0,0,0,0,
			0,1,1,1,0
			0,0,0,1,0,
	};
  ```
	  上数组表示一个迷宫，0：墙壁;1：路;要求只能横、竖走，不能斜着走。
	   找到从左上角到右下角所有的路线。
# 深度优先搜索
* 利用堆栈，把走过的路线记录并压栈。利用所走过路线的每个前趋点，保存
上一步走的位置，后继点表示下一步走的位置。<br>
例如：`pedecessor[4][4]`为（3，4）的坐标位置，表示从（3，4）->(4,4)<br>
* 其伪码如下：<br>
```
 将起点标记为已走过并`压栈`;
 while (栈非空) {
	 从栈顶弹出一个点p;
	 if (p这个点是终点)
		 break;
	 否则沿右、下、左、上四个方向探索相邻的点
	 if (和p相邻的点有路可走，并且还没走过)
		 将相邻的点标记为已走过并压栈，它的前趋就是p点;
 }
 if (p点是终点) {
	 打印p点的座标;
	 while (p点有前趋) {
		 p点 = p点的前趋;
		 打印p点的座标;
	 }
 } else
没有路线可以到达终点;
```
* 深度优先搜索图解

	![](https://github.com/GXTAO/Algorithm/blob/master/Maze/Maze_stack/stackqueue.dfs.png)
# 广度优先搜索
* 利用队列中FIFO方式进行数据的入队和出队操作。设置队头和队尾两个指针。对头总是指向元素的的队头;队尾指向下一个元素。Predecessor成员指针，指向它所指元素的前趋节点。利用数据结构中广度优先搜索进行路线的排序。
* 广度优先搜索队列图解

	![](https://github.com/GXTAO/Algorithm/blob/master/Maze/Maze_Queue/stackqueue.bfsqueue.png)
* 伪码如下：
```
将起点标记为已走过并入队;
while (队列非空) {
	出队一个点p;
	if (p这个点是终点)
		break;
	否则沿右、下、左、上四个方向探索相邻的点
	if (和p相邻的点有路可走，并且还没走过)
		将相邻的点标记为已走过并入队，它的前趋就是刚出队的p点;
}
if (p点是终点) {
	打印p点的座标;
	while (p点有前趋) {
		p点 = p点的前趋;
		打印p点的座标;
	}
} else
	没有路线可以到达终点;
```
